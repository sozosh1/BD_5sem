# Конспект

# Лабы

## Лабораторная №1
```
CREATE TABLE clients (
  id SERIAL PRIMARY KEY,
  last_name VARCHAR(50),
  first_name VARCHAR(50),
  father_name VARCHAR(50),
  passport_seria VARCHAR(4),
  passport_number VARCHAR(6)
);

CREATE TABLE book_types (
  id SERIAL PRIMARY KEY,
  type VARCHAR(20),
  fine DECIMAL(10,2),
  day_count INTEGER
);

CREATE TABLE books (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  cnt INTEGER,
  type_id INTEGER,
  FOREIGN KEY (type_id) REFERENCES book_types(id) ON DELETE CASCADE
);

CREATE TABLE journal (
  id SERIAL PRIMARY KEY,
  book_id INTEGER,
  client_id INTEGER,
  date_beg DATE DEFAULT CURRENT_DATE,
  date_end DATE,
  date_ret DATE,
  FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE,
  FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE
);
```
## Лабораторная №2
### Выборка данных

#### - однотабличная выборка

1.     Вывести все строки из журнала библиотекаря дата возврата которых меньше некоторой даты

```
 select * from journal where date_ret < '2024-09-18';

```
![[Pasted image 20241022212606.png]]

2.     Посчитать количество книг, которых нет в наличии
```
select count(*) from books where cnt = 1; 
```

| cnt = 0                              | cnt = 1                              |
| ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20241022212815.png]] | ![[Pasted image 20241022212854.png]] |

#### - выборка с подзапросами

1. Вывести все книги типа «уникальные», которые на руках у читателей
```
select *
from books
where type_id in (select id from book_types where type like 'уникальн%')
and id in (select book_id from journal where date_ret IS NULL);
```
![[Pasted image 20241022213418.png]]
#### - соединение таблиц (join)

1. Вывести журнал библиотекаря, читателей, включая читателей, которые не брали книг и книги, включая книги, которых не выдавали
```
select *
from journal
         full outer join public.clients c on journal.client_id = c.id
         full outer join public.books b on journal.book_id = b.id;
```
![[Pasted image 20241022213518.png]]
#### - для реализации проекта

1. Число книг на руках у заданного клиента.
```
select count(*)
from journal
where client_id = 5
and date_ret is null;
```
![[Pasted image 20241022213732.png]]
2. Размер штрафа заданного клиента.
```
   select sum((j.date_ret - j.date_end) * book_types.fine)
from journal j
         inner join books b on j.book_id = b.id
         inner join book_types on b.type_id = book_types.id
where j.client_id = 8 
  and date_ret > date_end;
```
![[Pasted image 20241022214111.png]]
3. Размер самого большого штрафа
```
   select max((j.date_ret - j.date_end) * book_types.fine)
from journal j
         inner join books b on j.book_id = b.id
         inner join book_types on b.type_id = book_types.id
where date_ret > date_end;
```
![[Pasted image 20241022214153.png]]
4. Три самые популярные книги
```
   select b.name
from journal j
         join books b on j.book_id = b.id
group by b.name
order by count(b.name)
limit 3;
```
   ![[Pasted image 20241022214210.png]]

==Hints: select, count, join, where, in, exists, order by, group by, having==

_Понимать чем отличаются конструкции:_ _inner_ _join__,_ _left__/__right__/__full_ _outer_ _join_

### Вставка данных

#### ·       однотабличная вставка

1.     Добавить нового клиента
```
insert into clients (last_name, first_name, father_name, passport_seria, passport_number)
values ('Арбаева', 'Арина', 'Федоровна', 8118, 793240);
```
![[Pasted image 20241022214340.png]]
#### ·       многотабличная вставка в рамках транзакции

1.     Добавить в рамках транзакции клиента, книгу и запись в журнал библиотекаря о выдачи книги этому клиенту
```
do
$$
    declare
        clientid integer;
        bookid   integer;
        typeid   integer;
    BEGIN

        insert into clients (first_name, last_name, father_name, passport_seria, passport_number)
        values ('Голубь', 'Катарина', 'Антовновна', 2323, 678998)
        returning id into clientid;
        insert into books (name, cnt, type_id)
        values ('Черный лебедь', 3, 1)
        returning id, type_id into bookid, typeid;
        insert into journal (book_id, client_id, date_beg, date_end, date_ret)
        values (bookid, clientid, CURRENT_DATE,
                current_date + (select day_count from book_types where book_types.id = typeid), null);
        COMMIT;
    end
$$;
```
![[Pasted image 20241022214503.png]]
2.     Добавить запись в журнал, в случае, если книг у данного клиента больше 10, транзакцию откатить
```
do
$$
    declare
        clientid integer;
    begin
        insert into journal(book_id, client_id, date_beg, date_end, date_ret)
        values (3, 5, CURRENT_DATE, current_date + (select day_count
                                                    from book_types
                                                    where id = (select type_id from books where books.id = 3)),
                null)
        returning client_id into clientid;
        if (select count(*) from journal where journal.client_id = clientid and journal.date_ret is null) > 10 then
            rollback;
        else
            commit ;
        end if;
    end
$$;
```
![[Pasted image 20241022214557.png]]
==Hints: insert, where, in, exists, commit, rollback==
### Удаление данных

#### ·       удаление по фильтру и удаление из связанных таблиц

1.     Удалить книги, не имеющие ссылок из записей в журнале

```
delete
from books
where id not in (select journal.book_id from journal);

```
![[Pasted image 20241022214839.png]]
#### ·       удаление в рамках транзакции

1.     Удалить в рамках транзакции книгу и записи о ее выдаче

```
begin;
delete
from books
where id = 1;
delete
from journal
where book_id = 1;
commit;
```
![[Pasted image 20241022214900.png]]
2.     то же, что и п1, но транзакцию откатить
```
begin;
delete
from books
where id = 1;
delete
from journal
where book_id = 1;
rollback;
```
![[Pasted image 20241022214922.png]]
==Hints: delete, where, in, exists, commit, rollback==

_Рассмотрите различия команд_ _delete_ _и_ _truncate_

### Модификация данных

#### ·       модификация по фильтру

1.     Заменить уже выданную заданному клиенту книгу на другую
```
begin;
update journal
set book_id  = 3,
    date_end = date_beg + (select day_count
                           from book_types
                           where id = (select type_id from books where books.id = 3)) where book_id = 1;
delete from books where id = 1;
commit ;
```
![[Pasted image 20241022214941.png]]
#### ·       модификация в рамках транзакции

1.     В рамках транзакции поменять заданную книгу во всех записях журнала на другую и удалить ее.
```
begin;
update journal
set book_id  = 3,
    date_end = date_beg + (select day_count
                           from book_types
                           where id = (select type_id from books where books.id = 3)) where book_id = 1;
delete from books where id = 1;
commit ;
```
![[Pasted image 20241022215039.png]]

2.     то же, что и п1, но транзакцию откатить
```
begin;
update journal
set book_id  = 3,
    date_end = date_beg + (select day_count
                           from book_types
                           where id = (select type_id from books where books.id = 3)) where book_id = 1;
delete from books where id = 1;
rollback ;
```
![[Pasted image 20241022215056.png]]

==Hints: update, where, in, exists, commit, rollback==

**Что такое DML** _в PostgreSQL?_
## Лабораторная №3
### Представления

1.     Создать представление, отображающее все книги и читателей, о которых найдены записи в журнале с заданной даты по заданную дату
```
create view  as
select j.book_id, j.client_id, b.name 
as book_name, c.last_name, c.first_name,j.date_beg, j.date_end, j.date_ret
from journal j 
join books b on j.book_id = b.id
join clients c on j.client_id = c.id
where j.date_beg between '2024-01-01' and '2024-12-31'
```
![[Pasted image 20241022224501.png|600]]

2.     Создать представление, отображающее всех читателей и количество книг, находящихся у них на руках
```
create view vwClientsBooksCount as
select c.id, c.last_name, c.first_name, count(j.book_id) as books_on_hand
from clients c
left join journal j on c.id = j.client_id
where j.date_ret IS null
group by c.id, c.last_name, c.first_name;
```

![[Pasted image 20241022230209.png]]
==Hints: select, where, count, max, group by, having, like, create view, drop view==

### Хранимые процедуры

_Перед созданием хранимых процедур изучите разницу между хранимыми функциями и процедурами в PostgreSQL._ _Обоснуйте на основе материалов лекций почему требуется создание именно хранимых процедур._

#### ·       без параметров

1.     Создать хранимую процедуру, выводящую все книги и среднее время, на которое их брали в днях
```
CREATE OR REPLACE PROCEDURE avg_borrow_time()
LANGUAGE plpgsql AS $$
DECLARE
    book_name VARCHAR;
    avg_borrow_days NUMERIC;
BEGIN
    FOR book_name, avg_borrow_days IN
        SELECT b.name, AVG(j.date_ret - j.date_beg) AS avg_borrow_days
        FROM journal j
        JOIN books b ON j.book_id = b.id
        WHERE j.date_ret IS NOT NULL
        GROUP BY b.name
    LOOP
        RAISE NOTICE 'Book: %, Average Borrow Days: %', book_name, avg_borrow_days;
    END LOOP;
END;
$$;
```
![[Pasted image 20241022232950.png]]
#### ·       с входными параметрами

1.     Создать хранимую процедуру, имеющую два параметра «книга1» и «книга2». Она должна возвращать клиентов, которые вернули «книгу1» быстрее чем «книгу2». Если какой-либо клиент не брал одну из книг – он не рассматривается.
```
CREATE OR REPLACE PROCEDURE compare_return_times(book1 INT, book2 INT)
LANGUAGE plpgsql AS $$
BEGIN
    
    CREATE TEMP TABLE temp_clients_return_comparison (
        client_id INT,
        last_name VARCHAR,
        first_name VARCHAR,
        return_time_book1 INT,
        return_time_book2 INT
    );

    INSERT INTO temp_clients_return_comparison (client_id, last_name, first_name, return_time_book1, return_time_book2)
    SELECT j1.client_id, c.last_name, c.first_name,
           EXTRACT(DAY FROM (AGE(j1.date_ret, j1.date_beg))) AS return_time_book1,
           EXTRACT(DAY FROM (AGE(j2.date_ret, j2.date_beg))) AS return_time_book2
    FROM journal j1
    JOIN journal j2 ON j1.client_id = j2.client_id
    JOIN clients c ON j1.client_id = c.id
    WHERE j1.book_id = book1
      AND j2.book_id = book2
      AND j1.date_ret IS NOT NULL
      AND j2.date_ret IS NOT NULL
      AND (j1.date_ret - j1.date_beg) < (j2.date_ret - j2.date_beg);

END;
$$;

```
![[Pasted image 20241022234134.png]]
#### ·       с выходными параметрами

1.     Создать хранимую процедуру с входным параметром «клиент» и выходным параметром – количеством книг, находящихся у него
```
CREATE OR REPLACE PROCEDURE books_on_hand(client_param INT, OUT book_count INT)
LANGUAGE plpgsql AS $$
BEGIN
    SELECT COUNT(*) INTO book_count
    FROM journal
    WHERE journal.client_id = client_param AND date_ret IS NULL;
END;
$$;
```

```
DO $$
DECLARE
    book_count INT;
BEGIN
    CALL books_on_hand(5, book_count);
    RAISE NOTICE 'Количество книг на руках у клиента: %', book_count;
END $$;
```
![[Pasted image 20241022234842.png]]

2.     Создать хранимую процедуру с входным параметром «книга» и двумя выходными параметрами, возвращающими самое большое время на который брали книгу и читателя, поставившего рекорд
```
CREATE OR REPLACE PROCEDURE longest_borrow_time(
    book_id_param INT,
    OUT max_borrow_days INT,
    OUT record_holder VARCHAR
)
LANGUAGE plpgsql AS $$
DECLARE
    temp_client_id INT;
    temp_max_interval INTERVAL;
BEGIN
    
    SELECT client_id, (date_ret - date_beg) AS borrow_interval
    INTO temp_client_id, temp_max_interval
    FROM journal
    WHERE journal.book_id = book_id_param AND date_ret IS NOT NULL
    ORDER BY borrow_interval DESC
    LIMIT 1;
    
    IF temp_max_interval IS NOT NULL THEN
    
        max_borrow_days := EXTRACT(DAY FROM temp_max_interval);
        SELECT CONCAT(last_name, ' ', first_name)
        INTO record_holder
        FROM clients
        WHERE clients.id = temp_client_id;
    ELSE
        max_borrow_days := 0;
        record_holder := 'Запись не найдена';
    END IF;
END;
$$;

```

```
DO $$
DECLARE
    max_days INT;
    holder_name VARCHAR;
BEGIN
    CALL longest_borrow_time(19 ,max_days, holder_name);
	
    RAISE NOTICE 'Максимальное количество дней: %, Читатель-рекордсмен: %', max_days, holder_name;
END $$;

```
![[Pasted image 20241023002116.png]]
==Hints: select, where, count, max, group by, having, create procedure, drop procedure==

**??Разберите возможность выбора языка sql  и plpgsql.  На чем основывается Ваш выбор?**

### Триггера

#### ·       Триггера на вставку

1.     Создать триггер, который не позволяет добавить читателя с номером паспорта, который уже есть у существующего читателя
```
CREATE OR REPLACE FUNCTION prevent_duplicate_passport()
RETURNS TRIGGER AS $$
BEGIN
    
    IF EXISTS (
        SELECT 1 
        FROM clients 
        WHERE passport_seria = NEW.passport_seria 
          AND passport_number = NEW.passport_number
    ) THEN
        RAISE EXCEPTION 'Клиент с таким номером паспорта уже существует';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

```
CREATE TRIGGER check_passport_duplicate BEFORE INSERT OR UPDATE ON clients FOR EACH ROW EXECUTE FUNCTION prevent_duplicate_passport();
```
![[Pasted image 20241022235900.png]]
#### ·       Триггера на модификацию

1.     Создать триггер, который не позволяет установить реальную дату возврата журнала библиотекаря меньше, чем дата выдачи
```
CREATE OR REPLACE FUNCTION check_return_date()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.date_ret IS NOT NULL AND NEW.date_ret < NEW.date_beg THEN
        RAISE EXCEPTION 'Дата возврата (%), не может быть меньше даты выдачи (%)', NEW.date_ret, NEW.date_beg;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

```

```

CREATE TRIGGER validate_return_date
BEFORE INSERT OR UPDATE ON journal
FOR EACH ROW
EXECUTE FUNCTION check_return_date();

```
![[Pasted image 20241023000236.png]]
#### - Триггера на удаление

1.     Создать триггер, который при удалении строки журнала в случае, если книга не возвращена - откатывает транзакцию
```
CREATE OR REPLACE FUNCTION prevent_delete_if_not_returned()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.date_ret IS NULL THEN
        RAISE EXCEPTION 'Невозможно удалить запись из журнала, так как книга еще не возвращена.';
    END IF;

    RETURN OLD;
END;
$$ LANGUAGE plpgsql;


```

```
CREATE OR REPLACE FUNCTION dont_delete_user()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.passport_number LIKE '1918%' THEN
        RAISE EXCEPTION 'Нельзя удалить';
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;
```

```
CREATE TRIGGER check_pass_number
BEFORE DELETE ON clients
FOR EACH ROW
EXECUTE FUNCTION dont_delete_user;
```

```
CREATE TRIGGER prevent_delete_unreturned_book
BEFORE DELETE ON journal
FOR EACH ROW
EXECUTE FUNCTION prevent_delete_if_not_returned();

```

![[Pasted image 20241023000514.png]]

==Hints: select, where, in, exists, join, commit, rollback, create trigger, drop trigger==

_Разберите особенности работы триггера_ _FOR EACH STATEMENT/ FOR EACH ROW_

### Курсоры

#### - Хранимая процедура для расчета суммы штрафов библиотеки

Необходимо реализовать хранимую процедуру, рассчитывающую сумму штрафов, полученную библиотекой за некоторый период времени. Хранимая процедура должна иметь два входных параметра задающие интервал времени и один выходной, куда будем возвращать размер штрафа.

Предлагаемый алгоритм: создаем курсор, который пробегает по строкам журнала (реальная дата возврата попадает в заданный интервал). Для каждой строки рассчитываем размер штрафа и суммируем его в некоторой переменной, значение которой по окончании работы курсора будет выдано в качестве выходного параметр с общей суммой штрафов.
```
CREATE OR REPLACE PROCEDURE calculate_fines_sum(
    start_date DATE,
    end_date DATE,
    OUT total_fine NUMERIC
)
LANGUAGE plpgsql AS $$
DECLARE
    fine_cursor CURSOR FOR
        SELECT j.book_id, j.date_beg, j.date_end, j.date_ret, bt.fine
        FROM journal j
        JOIN books b ON j.book_id = b.id
        JOIN book_types bt ON b.type_id = bt.id
        WHERE j.date_ret IS NOT NULL AND j.date_ret BETWEEN start_date AND end_date;

    book_id INT;
    date_beg DATE;
    date_end DATE;
    date_ret DATE;
    fine NUMERIC;
    current_fine NUMERIC;
BEGIN
    
    total_fine := 0;

   
    OPEN fine_cursor;

    
    LOOP
        FETCH fine_cursor INTO book_id, date_beg, date_end, date_ret, fine;
        
        
        EXIT WHEN NOT FOUND;

        
        IF date_ret > date_end THEN
            current_fine := fine * (date_ret - date_end);
            total_fine := total_fine + current_fine;
        END IF;
    END LOOP;

    
    CLOSE fine_cursor;
END;
$$;

`````

```
DO $$
DECLARE
    total_fine NUMERIC;
BEGIN
   
    CALL calculate_fines_sum('2024-01-01', '2024-12-31', total_fine);


    RAISE NOTICE 'Общая сумма штрафов за период: %', total_fine;
END $$;
```
![[Pasted image 20241023001621.png]]
#### - Хранимая процедура для расчета трех самых популярных книг

Необходимо реализовать хранимую процедуру, выбирающую три самые популярные книги за некоторый интервал времени. Хранимая процедура должна иметь два входных параметра задающие интервал времени.

Предлагаемый алгоритм: Создаем три переменные, хранящие идентификаторы самых популярных книг и 3 переменные, соответственно хранящие число их выдачей. Создаем курсор, который пробегает по всем книгам, реальная дата выдачи которых попадает в заданный интервал. Для каждой книги рассчитываем количество ее выдачей и, в случае, если она была выдана большее число раз, нежели одна из сохраненных в наших переменных, то заменяем ее новой. По окончании работы курсора выбираем идентификаторы самых популярных книг.
```
CREATE OR REPLACE PROCEDURE top_three_books(
    start_date DATE,
    end_date DATE
)
LANGUAGE plpgsql AS $$
DECLARE
    -- Переменные для хранения идентификаторов и количества выдач трех самых популярных книг
    top1_book_id INT := NULL;
    top2_book_id INT := NULL;
    top3_book_id INT := NULL;

    top1_count INT := 0;
    top2_count INT := 0;
    top3_count INT := 0;

    -- Курсор для прохода по всем книгам, дата выдачи которых попадает в интервал
    book_cursor CURSOR FOR
        SELECT book_id, COUNT(*) AS issue_count
        FROM journal
        WHERE date_beg BETWEEN start_date AND end_date
        GROUP BY book_id;

    current_book_id INT;
    current_issue_count INT;
BEGIN
    -- Открываем курсор
    OPEN book_cursor;

    -- Обходим все книги, которые попадают под условия курсора
    LOOP
        FETCH book_cursor INTO current_book_id, current_issue_count;

        EXIT WHEN NOT FOUND;

        -- Логика для определения трех самых популярных книг
        IF current_issue_count > top1_count THEN
            -- Сдвигаем второй и третий элементы вниз
            top3_book_id := top2_book_id;
            top3_count := top2_count;

            top2_book_id := top1_book_id;
            top2_count := top1_count;

            -- Обновляем первую книгу
            top1_book_id := current_book_id;
            top1_count := current_issue_count;

        ELSIF current_issue_count > top2_count THEN
            -- Сдвигаем третий элемент вниз
            top3_book_id := top2_book_id;
            top3_count := top2_count;

            -- Обновляем вторую книгу
            top2_book_id := current_book_id;
            top2_count := current_issue_count;

        ELSIF current_issue_count > top3_count THEN
            -- Обновляем третью книгу
            top3_book_id := current_book_id;
            top3_count := current_issue_count;
        END IF;
    END LOOP;

    -- Закрываем курсор
    CLOSE book_cursor;

    -- Вывод результата
    RAISE NOTICE 'Самые популярные книги: 1) ID: %, Выдач: %; 2) ID: %, Выдач: %; 3) ID: %, Выдач: %',
        top1_book_id, top1_count, top2_book_id, top2_count, top3_book_id, top3_count;
END;
$$;

```

```
CALL top_three_books('2024-01-01', '2024-12-31');
```
![[Pasted image 20241023001548.png]]
# Курсовая
В рамках данного цикла лабораторных работ необходимо автоматизировать работу библиотеки. Для этого в рамках базы данных PostgreSQL необходимо создать объекты в схеме вашего пользователя (логин и пароль пользователя для доступа к базе данных студент должен получить у преподавателя)  
Библиотека является государственным предприятием и выдает литературу жителям Выборгского района (далее клиентам) на безвозмездной основе. Клиенты характеризуются фамилией, именем и номером паспорта. Клиент не может иметь на руках более 10 книг. Книги библиотеки характеризуются полным наименованием и разбиты на 3 категории: обычные, редкие и уникальные. Максимальные сроки удержания клиентом книги зависят от категории книги и составляют соответственно 60, 21 и 7 дней. Если клиент не возвращает книги в оговоренный срок, то обязан уплатить штраф из расчета 10, 50 и 300 рублей за день задержки так же в зависимости от категории книги. Экземпляров книг в библиотеке ограниченное количество и при выдаче и возврате их необходимо вести учет числа экземпляров каждой книги. Библиотекари при выдаче и приеме книг обязаны учитывать все операции в журнале. При выдаче книги в журнал необходимо заносить дату выдачи (автоматически: текущая дата), клиента (библиотекарь выбирает из справочника), книгу (библиотекарь выбирает из справочника) и максимальную дату возврата (автоматически: текущая дата + количество дней, в зависимости от типа книги). При приеме книги устанавливается реальная дата возврата и, при необходимости, исчисляется штраф.  
  
База данных должна удовлетворять следующим требованиям:  
1. Контроль целостности данных, используя механизм связей  
2. Операции модификации групп данных и данных в связанных таблицах должны быть выполнены в рамках транзакций.  
3. Логика работы приложения должна контролироваться триггерами. В частности:  
• Триггер должен не позволять выдать книгу, не имеющуюся в наличии.  
• Триггер должен контролировать, что выдаваемая книга выдается клиенту, имеющему на руках менее 10 книг  
4. Все операции вычисления различных показателей (из требований к клиентскому приложению) должны реализовываться хранимыми процедурами.  
Требования к клиентскому приложению:  
1. Вход в приложение осуществляется после корректного введения пароля и логина с соответствующими ролями (пользователь не может вносить изменения в БД, администратор владеет всеми правами). Логин и пароль хранятся в виде хэшей.  
2. Необходимо реализовать интерфейсы для ввода, модификации и удаления  
• Клиентов  
• Книг  
• Типов книг.  
3. В главном окне приложения должен быть реализован журнал библиотекаря с возможностью выдачи и приема книг.  
4. Необходимо реализовать возможность просмотра библиотекарем следующих показателей:  
• Число книг на руках у клиента.  
• Размер самого большого штрафа  
• Размер штрафа данного клиента.  
• Три самые популярные книги  
а) отдельный файл параметров подключения к БД, который задаются файлом (формат plain text file  
или ini config file или xml file);  
б) авторизацию с хешированием паролей для пользователей (2 пользователя);  
в) меню приложения содержит группы элементов: СПРАВОЧНИКИ, ЖУРНАЛЫ, ОТЧЕТЫ;  
г) приложение должно обеспечивать ввод, редактирование, просмотр информации из БД;  
д) используется пользовательский элементы вида GridView для обзора таблиц (представлений) БД;  
е) GridView, который содержит внешние ключи, должен содержать нужные/необходимые атрибуты  
внешней таблицы.  
ж) есть отдельная форма для работы с записью таблицы, содержащая эл-ты интерфейса ДОБАВИТЬ,  
ИЗМЕНИТЬ, УДАЛИТЬ, ЗАКРЫТЬ; открывается из GridView  
з) меню пункта ОТЧЕТЫ вызывает формы вывода отчетов (минимум 2-х) (выходной формат txt или  
xls или pdf). В @Базы данных.md указано, что я уже сделала также можно использовать ORM.Давай постепенно делать эту работу по шагам и каждый шаг тестировать